# Access Token Broker

Access token broker is a method of authenticating the origin of a Google Cloud Platform (GCP) request using OAuth tokens and mutual TLS authentication. It consists of a token broker server and an on-premises client application that uses access tokens issued by the server to authorize actions such as uploading files to GCS and sending load jobs to BigQuery.

An access token allows the on-premises client to act on behalf of a service account authorized to access the required GCP services. This approach is extensible to a broader class of use cases around managing resource access in a hybrid cloud environment.

## OAuth on Google Cloud Platform

A client can authenticate and authorize to a GCP API using the OAuth 2.0 protocol. To begin the authentication, the client needs to obtain OAuth 2.0 client credentials from the Google API. It can be credentials that belong to a service account or user account. Then the client application requests an access token, extracts a token from the response, and sends the token to the Google API that you want to access. In this way, it can, for example, protect access to the data stored in GCP from unauthorized access. An important goal for OAuth is to provide secure and convenient access to the protected data while minimizing the potential impact if an access token is stolen (unlike a service account key, an access token expires in one hour or less).

When an application is executed on GCE, it can use client library, gcloud, or gsutil tools to request access to resources on behalf of a service account associated with the GCE instance. However, you can also request an OAuth2 access token directly and use it later for authentication.

OAuth 2.0 supports a client-application-centric flow, which allows sending and storing an access token outside of the application host, in our case a GCE instance. This capability is important in a hybrid environment, where on-premises applications cannot benefit from an integration layer with the IAM service such as GCE metadata service.

A single access token can grant varying degrees of access to multiple APIs. A parameter called scope controls the set of resources and operations that an access token permits.

## Access Token Broker server

Access Token Broker (ATB) web server application runs on a Google Compute Engine instance. To request an OAuth2 access token, the web server application issues an HTTP GET request to Cloud IAM. Cloud IAM generates a temporary access token, that grants permissions associated with the service account and scope passed as parameters in the Cloud IAM request. The GCE instance that runs the ATB application must have permissions to create IAM tokens. Then, ATB sends the token to the client as part of the HTTPS session established earlier by the client requesting access to the GCP resources. The access token generated by the service expires in one hour or less.

If tokens for multiple service accounts need to be generated by the same ATB instance, the web server should issue tokens with different scopes based on the client certificate. Another way of managing more than one client IAM role is to create an ATB server per role. This approach requires more maintenance but itâ€™s more secure because compromising one ATB VM gives an attacker access to resources granted by the role attached to this VM only (assuming the ATB instance is in a separate project).

## Client/server authentication

At the beginning of the process, a security admin, or another authorized entity, must upload a digital certificate signed by the company Certificate Authority (CA) to the client application host. The client certificate must have a fully qualified domain name (FQDN) entry associated with client host.

The certificate can be supplied to the client application in the form of an environment variable.

Then, the security admin or deployment manager service must upload a server-side certificate with the server FQDN to the ATB server GCE instance.

When the client makes an HTTPS request to the token broker server, bidirectional Transport Layer Security (TLS) authentication is used to establish the connection.

After the client application is authenticated against the token broker, the client application attaches the token obtained from the server to a GCP API request tha required authentication (for example, to GCS and BigQuery).

When a token expires, all requests using that access token fail, regardless of whether the corresponding account has permission on the bucket or another resource. Client and token broker certificates should be rotated.

# Creating Token Broker Test Instance

1. Enable Google Cloud Platform IAM token API: https://console.developers.google.com/apis/api/iamcredentials.googleapis.com/overview
1. Create a service account with IAM roles that must be granted to your client-side application. This service account will be impersonated by the client application, i.e. the client application will have access to all resources that this service account has. In this example, the client service account has write access to GCS.
1. Create a GCE instance in a secured subnet and assign it a service account with a role called *Service Account Token Creator*. This role is required to generate IAM tokens. We will use *token-broker* as the name of the instance going forward. These instructions were written for Debian but the python script that runs Token Broker can be run on any operating system supported by Google Cloud SDK.

   1. Ssh to the created token broker GCE instance and run the following command:
   1. Pull a repository with Token Broker code from the github repository to the new GCE instance.
   1. Cd to the token-broker directory and run the following command:

          openssl req -new -x509 -keyout ./token_broker.pem -out ./token_broker.pem -days 365 -nodes
   1. Check that a private/public key pair was created in `token_broker.pem` file. This key will be used for a TLS certificate used by the Token Broker server.

 1. Create a client-side GCE instance that will request tokens from the token broker server. We will use *tb-client* as the name of the client instance going forward.
    1. Ssh to the new instance and install jdk with maven:

           sudo apt-get install openjdk-9-jdk maven
    1. Create a client key store:

           keytool -genkey -dname "cn=CLIENT" -alias truststorekey -keyalg RSA -keystore ./client-truststore.jks -keypass 123456 -storepass 123456 # Use a stronger password for production usage
    1. Copy the server certificate to the client node. Only a public portion of the key is required in production.

           gcloud compute scp token-broker:~/token_broker.pem .
    1. Convert the key from PEM to DER format:

           openssl x509 -outform der -in token_broker.pem -out token_broker.der
    1. Add the server key to the client key store:

           keytool -import -alias token_broker -keystore client-truststore.jks -file token_broker.der
    1. Add standard java keys to the client key store (when prompted enter the password "changeit"):

           sudo keytool -importkeystore -srckeystore /usr/lib/jvm/java-9-openjdk-amd64/lib/security/cacerts -destkeystore client-truststore.jks -srcstoretype JKS -deststorepass 123456o
    1. Find the clinet FQDN:

           curl http://metadata.google.internal/computeMetadata/v1/instance/hostname  -H "Metadata-Flavor: Google"
    1. Generate a client key used for authentication against the Token Broker server:

           openssl req -new -x509 -keyout client.pem -out client.pem -days 365 -nodes
    1. Convert the client certificate to PFX format:

           openssl pkcs12 -export -in client.pem -inkey client.pem -out client.p12
    1. Copy the client certificate to the TB instance:

           gcloud compute scp client.pem token-broker:~

1. Ssh back to the token broker instance and import the client certificate to the server key store:

       cat /etc/ssl/certs/ca-certificates.crt client.pem > ~/ca-bundle.crt
1. Install google-auth python library:

       pip3 install google-auth

1. Run the token broker server:

       ./token_broker.py $(curl -s http://metadata.google.internal/computeMetadata/v1/instance/hostname -H "Metadata-Flavor: Google") 4443 token_broker.pem <Service account email from Step #2> ca-bundle.crt

   Verify successful server start.

1. On the client machine download the repository and change directory to `client`. This directory has client code that uploads data to GCS using the token broker.

1. Set environment variables and build the client application:

       export PATH_TO_REPO=<Path to github repo>
       cd $PATH_TO_REPO/client/Authtest
       export TB_INSTANCE_NAME=token-broker
       mvn package && cp target/broker-client-1.0-SNAPSHOT-jar-with-dependencies.jar ../../
       cd -

1. Run the sample java client:

        export TOKEN_BROKER_DNS=<Token Broker FQDN>
        java -Djavax.net.ssl.keyStoreType=pkcs12 -Djavax.net.ssl.keyStore=client.p12 -Djavax.net.ssl.keyStorePassword=123456 -Djavax.net.ssl.trustStoreType=jks -Djavax.net.ssl.trustStore=client-truststore.jks -Djavax.net.ssl.trustStorePassword=123456 -Dtoken-broker.host=$TOKEN_BROKER_DNS $PATH_TO_REPO/client/Authtest/target/broker-client-1.0-SNAPSHOT-jar-with-dependencies.jar <bucket-name>

    You should see the output similar to this:

        Using client certificate at .../client.p12
        Using key store at .../client-truststore.jks
        Connecting to https://<Token Broker host>:443/token
        Loading data to GCS

